import path from 'path';
import { EOL } from 'os';

const toLowerCase = (str) => str.toLowerCase();
const dashToPascalCase = (str) => toLowerCase(str)
    .split('-')
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join('');
function sortBy(array, prop) {
    return array.slice().sort((a, b) => {
        const nameA = prop(a);
        const nameB = prop(b);
        if (nameA < nameB)
            return -1;
        if (nameA > nameB)
            return 1;
        return 0;
    });
}
function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar âž” foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (typeof str !== 'string') {
        throw new Error(`invalid path to normalize`);
    }
    str = str.trim();
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    str = str.replace(SLASH_REGEX, '/');
    // always remove the trailing /
    // this makes our file cache look ups consistent
    if (str.charAt(str.length - 1) === '/') {
        const colonIndex = str.indexOf(':');
        if (colonIndex > -1) {
            if (colonIndex < str.length - 2) {
                str = str.substring(0, str.length - 1);
            }
        }
        else if (str.length > 1) {
            str = str.substring(0, str.length - 1);
        }
    }
    return str;
}
function relativeImport(pathFrom, pathTo, ext) {
    let relativePath = path.relative(path.dirname(pathFrom), path.dirname(pathTo));
    if (relativePath === '') {
        relativePath = '.';
    }
    else if (relativePath[0] !== '.') {
        relativePath = './' + relativePath;
    }
    return normalizePath(`${relativePath}/${path.basename(pathTo, ext)}`);
}
async function readPackageJson(config, rootDir) {
    var _a;
    const pkgJsonPath = path.join(rootDir, 'package.json');
    let pkgJson;
    try {
        pkgJson = (await ((_a = config.sys) === null || _a === void 0 ? void 0 : _a.readFile(pkgJsonPath, 'utf8')));
    }
    catch (e) {
        throw new Error(`Missing "package.json" file for distribution: ${pkgJsonPath}`);
    }
    let pkgData;
    try {
        pkgData = JSON.parse(pkgJson);
    }
    catch (e) {
        throw new Error(`Error parsing package.json: ${pkgJsonPath}, ${e}`);
    }
    return pkgData;
}
const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
const NON_ASCII_REGEX = /[^\x00-\x80]+/;
const SLASH_REGEX = /\\/g;

const createComponentDefinition = (componentCorePackage, distTypesDir, rootDir, includeImportCustomElements = false, customElementsDir = 'components') => (cmpMeta) => {
    // Collect component meta
    const inputs = [
        ...cmpMeta.properties.filter((prop) => !prop.internal).map((prop) => prop.name),
        ...cmpMeta.virtualProperties.map((prop) => prop.name),
    ].sort();
    const outputs = cmpMeta.events.filter((ev) => !ev.internal).map((prop) => prop);
    const methods = cmpMeta.methods.filter((method) => !method.internal).map((prop) => prop.name);
    // Process meta
    const hasOutputs = outputs.length > 0;
    // Generate Angular @Directive
    const directiveOpts = [
        `selector: \'${cmpMeta.tagName}\'`,
        `changeDetection: ChangeDetectionStrategy.OnPush`,
        `template: '<ng-content></ng-content>'`,
    ];
    if (inputs.length > 0) {
        directiveOpts.push(`inputs: ['${inputs.join(`', '`)}']`);
    }
    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
    const outputsInterface = new Set();
    const outputReferenceRemap = {};
    outputs.forEach((output) => {
        Object.entries(output.complexType.references).forEach(([reference, refObject]) => {
            // Add import line for each local/import reference, and add new mapping name.
            // `outputReferenceRemap` should be updated only if the import interface is set in outputsInterface,
            // this will prevent global types to be remapped.
            const remappedReference = `I${cmpMeta.componentClassName}${reference}`;
            if (refObject.location === 'local' || refObject.location === 'import') {
                outputReferenceRemap[reference] = remappedReference;
                let importLocation = componentCorePackage;
                if (componentCorePackage !== undefined) {
                    const dirPath = includeImportCustomElements ? `/${customElementsDir || 'components'}` : '';
                    importLocation = `${normalizePath(componentCorePackage)}${dirPath}`;
                }
                outputsInterface.add(`import type { ${reference} as ${remappedReference} } from '${importLocation}';`);
            }
        });
    });
    const componentEvents = [
        '' // Empty first line
    ];
    // Generate outputs
    outputs.forEach((output, index) => {
        componentEvents.push(`  /**
   * ${output.docs.text} ${output.docs.tags.map((tag) => `@${tag.name} ${tag.text}`)}
   */`);
        /**
         * The original attribute contains the original type defined by the devs.
         * This regexp normalizes the reference, by removing linebreaks,
         * replacing consecutive spaces with a single space, and adding a single space after commas.
         **/
        const outputTypeRemapped = Object.entries(outputReferenceRemap).reduce((type, [src, dst]) => {
            return type
                .replace(new RegExp(`^${src}$`, 'g'), `${dst}`)
                .replace(new RegExp(`([^\\w])${src}([^\\w])`, 'g'), (v, p1, p2) => [p1, dst, p2].join(''));
        }, output.complexType.original
            .replace(/\n/g, ' ')
            .replace(/\s{2,}/g, ' ')
            .replace(/,\s*/g, ', '));
        componentEvents.push(`  ${output.name}: EventEmitter<CustomEvent<${outputTypeRemapped.trim()}>>;`);
        if (index === outputs.length - 1) {
            // Empty line to push end `}` to new line
            componentEvents.push('\n');
        }
    });
    const lines = [
        '',
        `${[...outputsInterface].join('\n')}
export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {${componentEvents.length > 1 ? componentEvents.join('\n') : ''}}

${getProxyCmp(cmpMeta.tagName, includeImportCustomElements, inputs, methods)}
@Component({
  ${directiveOpts.join(',\n  ')}
})
export class ${tagNameAsPascal} {`,
    ];
    lines.push('  protected el: HTMLElement;');
    lines.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {
    c.detach();
    this.el = r.nativeElement;`);
    if (hasOutputs) {
        lines.push(`    proxyOutputs(this, this.el, ['${outputs.map((output) => output.name).join(`', '`)}']);`);
    }
    lines.push(`  }`);
    lines.push(`}`);
    return lines.join('\n');
};
function getProxyCmp(tagName, includeCustomElement, inputs, methods) {
    const hasInputs = inputs.length > 0;
    const hasMethods = methods.length > 0;
    const proxMeta = [
        `defineCustomElementFn: ${includeCustomElement ? 'define' + dashToPascalCase(tagName) : 'undefined'}`
    ];
    if (hasInputs)
        proxMeta.push(`inputs: ['${inputs.join(`', '`)}']`);
    if (hasMethods)
        proxMeta.push(`methods: ['${methods.join(`', '`)}']`);
    return `@ProxyCmp({\n  ${proxMeta.join(',\n  ')}\n})`;
}

function generateAngularDirectivesFile(compilerCtx, components, outputTarget) {
    // Only create the file if it is defined in the stencil configuration
    if (!outputTarget.directivesArrayFile) {
        return Promise.resolve();
    }
    const proxyPath = relativeImport(outputTarget.directivesArrayFile, outputTarget.directivesProxyFile, '.ts');
    const directives = components
        .map((cmpMeta) => dashToPascalCase(cmpMeta.tagName))
        .map((className) => `d.${className}`)
        .join(',\n  ');
    const c = `
import * as d from '${proxyPath}';

export const DIRECTIVES = [
  ${directives}
];
`;
    return compilerCtx.fs.writeFile(outputTarget.directivesArrayFile, c);
}

async function generateValueAccessors(compilerCtx, components, outputTarget, config) {
    if (!Array.isArray(outputTarget.valueAccessorConfigs) ||
        outputTarget.valueAccessorConfigs.length === 0) {
        return;
    }
    const targetDir = path.dirname(outputTarget.directivesProxyFile);
    const normalizedValueAccessors = outputTarget.valueAccessorConfigs.reduce((allAccessors, va) => {
        const elementSelectors = Array.isArray(va.elementSelectors)
            ? va.elementSelectors
            : [va.elementSelectors];
        const type = va.type;
        let allElementSelectors = [];
        let allEventTargets = [];
        if (allAccessors.hasOwnProperty(type)) {
            allElementSelectors = allAccessors[type].elementSelectors;
            allEventTargets = allAccessors[type].eventTargets;
        }
        return Object.assign(Object.assign({}, allAccessors), { [type]: {
                elementSelectors: allElementSelectors.concat(elementSelectors),
                eventTargets: allEventTargets.concat([[va.event, va.targetAttr]]),
            } });
    }, {});
    await Promise.all(Object.keys(normalizedValueAccessors).map(async (type) => {
        const valueAccessorType = type; // Object.keys converts to string
        const targetFileName = `${type}-value-accessor.ts`;
        const targetFilePath = path.join(targetDir, targetFileName);
        const srcFilePath = path.join(__dirname, '../resources/control-value-accessors/', targetFileName);
        const srcFileContents = await compilerCtx.fs.readFile(srcFilePath);
        const finalText = createValueAccessor(srcFileContents, normalizedValueAccessors[valueAccessorType]);
        await compilerCtx.fs.writeFile(targetFilePath, finalText);
    }));
    await copyResources(config, ['value-accessor.ts'], targetDir);
}
function createValueAccessor(srcFileContents, valueAccessor) {
    const hostContents = valueAccessor.eventTargets.map((listItem) => VALUE_ACCESSOR_EVENTTARGETS.replace(VALUE_ACCESSOR_EVENT, listItem[0]).replace(VALUE_ACCESSOR_TARGETATTR, listItem[1]));
    return srcFileContents
        .replace(VALUE_ACCESSOR_SELECTORS, valueAccessor.elementSelectors.join(', '))
        .replace(VALUE_ACCESSOR_EVENTTARGETS, hostContents.join(`,${EOL}`));
}
function copyResources(config, resourcesFilesToCopy, directory) {
    if (!config.sys || !config.sys.copy) {
        throw new Error('stencil is not properly intialized at this step. Notify the developer');
    }
    const copyTasks = resourcesFilesToCopy.map((rf) => {
        return {
            src: path.join(__dirname, '../resources/control-value-accessors/', rf),
            dest: path.join(directory, rf),
            keepDirStructure: false,
            warn: false,
        };
    });
    return config.sys.copy(copyTasks, path.join(directory));
}
const VALUE_ACCESSOR_SELECTORS = `<VALUE_ACCESSOR_SELECTORS>`;
const VALUE_ACCESSOR_EVENT = `<VALUE_ACCESSOR_EVENT>`;
const VALUE_ACCESSOR_TARGETATTR = '<VALUE_ACCESSOR_TARGETATTR>';
const VALUE_ACCESSOR_EVENTTARGETS = `    '(<VALUE_ACCESSOR_EVENT>)': 'handleChangeEvent($event.target.<VALUE_ACCESSOR_TARGETATTR>)'`;

async function angularDirectiveProxyOutput(compilerCtx, outputTarget, components, config) {
    const filteredComponents = getFilteredComponents(outputTarget.excludeComponents, components);
    const rootDir = config.rootDir;
    const pkgData = await readPackageJson(config, rootDir);
    const finalText = generateProxies(filteredComponents, pkgData, outputTarget, config.rootDir);
    await Promise.all([
        compilerCtx.fs.writeFile(outputTarget.directivesProxyFile, finalText),
        copyResources$1(config, outputTarget),
        generateAngularDirectivesFile(compilerCtx, filteredComponents, outputTarget),
        generateValueAccessors(compilerCtx, filteredComponents, outputTarget, config),
    ]);
}
function getFilteredComponents(excludeComponents = [], cmps) {
    return sortBy(cmps, (cmp) => cmp.tagName).filter((c) => !excludeComponents.includes(c.tagName) && !c.internal);
}
async function copyResources$1(config, outputTarget) {
    if (!config.sys || !config.sys.copy || !config.sys.glob) {
        throw new Error('stencil is not properly initialized at this step. Notify the developer');
    }
    const srcDirectory = path.join(__dirname, '..', 'angular-component-lib');
    const destDirectory = path.join(path.dirname(outputTarget.directivesProxyFile), 'angular-component-lib');
    return config.sys.copy([
        {
            src: srcDirectory,
            dest: destDirectory,
            keepDirStructure: false,
            warn: false,
        },
    ], srcDirectory);
}
function generateProxies(components, pkgData, outputTarget, rootDir) {
    const distTypesDir = path.dirname(pkgData.types);
    const dtsFilePath = path.join(rootDir, distTypesDir, GENERATED_DTS);
    const componentsTypeFile = relativeImport(outputTarget.directivesProxyFile, dtsFilePath, '.d.ts');
    const imports = `/* tslint:disable */
/* auto-generated angular directive proxies */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, NgZone } from '@angular/core';
import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
    /**
     * Generate JSX import type from correct location.
     * When using custom elements build, we need to import from
     * either the "components" directory or customElementsDir
     * otherwise we risk bundlers pulling in lazy loaded imports.
     */
    const generateTypeImports = () => {
        let importLocation = outputTarget.componentCorePackage ? normalizePath(outputTarget.componentCorePackage) : normalizePath(componentsTypeFile);
        importLocation += outputTarget.includeImportCustomElements ? `/${outputTarget.customElementsDir || 'components'}` : '';
        return `import ${outputTarget.includeImportCustomElements ? 'type ' : ''}{ ${IMPORT_TYPES} } from '${importLocation}';\n`;
    };
    const typeImports = generateTypeImports();
    let sourceImports = '';
    /**
     * Build an array of Custom Elements build imports and namespace them
     * so that they do not conflict with the React wrapper names. For example,
     * IonButton would be imported as IonButtonCmp so as to not conflict with the
     * IonButton React Component that takes in the Web Component as a parameter.
     */
    if (outputTarget.includeImportCustomElements && outputTarget.componentCorePackage !== undefined) {
        const cmpImports = components.map(component => {
            const pascalImport = dashToPascalCase(component.tagName);
            return `import { defineCustomElement as define${pascalImport} } from '${normalizePath(outputTarget.componentCorePackage)}/${outputTarget.customElementsDir ||
                'components'}/${component.tagName}.js';`;
        });
        sourceImports = cmpImports.join('\n');
    }
    const final = [
        imports,
        typeImports,
        sourceImports,
        components
            .map(createComponentDefinition(outputTarget.componentCorePackage, distTypesDir, rootDir, outputTarget.includeImportCustomElements, outputTarget.customElementsDir))
            .join('\n'),
    ];
    return final.join('\n') + '\n';
}
const GENERATED_DTS = 'components.d.ts';
const IMPORT_TYPES = 'Components';

const angularOutputTarget = (outputTarget) => ({
    type: 'custom',
    name: 'angular-library',
    validate(config) {
        return normalizeOutputTarget(config, outputTarget);
    },
    async generator(config, compilerCtx, buildCtx) {
        const timespan = buildCtx.createTimeSpan(`generate angular proxies started`, true);
        await angularDirectiveProxyOutput(compilerCtx, outputTarget, buildCtx.components, config);
        timespan.finish(`generate angular proxies finished`);
    },
});
function normalizeOutputTarget(config, outputTarget) {
    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfig: outputTarget.valueAccessorConfig || [] });
    if (config.rootDir == null) {
        throw new Error('rootDir is not set and it should be set by stencil itself');
    }
    if (outputTarget.directivesProxyFile == null) {
        throw new Error('directivesProxyFile is required');
    }
    if (outputTarget.directivesProxyFile && !path.isAbsolute(outputTarget.directivesProxyFile)) {
        results.directivesProxyFile = normalizePath(path.join(config.rootDir, outputTarget.directivesProxyFile));
    }
    if (outputTarget.directivesArrayFile && !path.isAbsolute(outputTarget.directivesArrayFile)) {
        results.directivesArrayFile = normalizePath(path.join(config.rootDir, outputTarget.directivesArrayFile));
    }
    if (outputTarget.directivesUtilsFile && !path.isAbsolute(outputTarget.directivesUtilsFile)) {
        results.directivesUtilsFile = normalizePath(path.join(config.rootDir, outputTarget.directivesUtilsFile));
    }
    return results;
}

export { angularOutputTarget };
